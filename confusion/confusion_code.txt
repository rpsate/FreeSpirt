int rfd;
int wfd;
int connver;
int req_count;
int dir_count;
int file_count;
uint8_t *p;
size_t len;
size_t size;
struct buffer buf;
struct conn *conn;
struct list_head *prev;
struct list_head *next;
unsigned int want_reply;
sem_t ready;
uint8_t reply_type;
uint32_t id;
int replied;
int error;
struct buffer reply;
struct timeval start;
void *data;
request_func end_func;
size_t len;
struct list_head list;
struct conn *conn;
int num_reqs;
pthread_cond_t finished;
int error;
struct sshfs_io *sio;
struct list_head list;
struct buffer data;
size_t size;
ssize_t res;
struct buffer handle;
struct list_head write_reqs;
pthread_cond_t write_finished;
int write_error;
struct read_chunk *readahead;
off_t next_pos;
int is_seq;
struct conn *conn;
int connver;
int modifver;
char *directport;
char *ssh_command;
char *sftp_server;
struct fuse_args ssh_args;
char *workarounds;
int rename_workaround;
int renamexdev_workaround;
int truncate_workaround;
int buflimit_workaround;
int unrel_append;
int fstat_workaround;
int createmode_workaround;
int transform_symlinks;
int follow_symlinks;
int no_check_root;
int detect_uid;
int idmap;
int nomap;
int disable_hardlink;
int dir_cache;
int show_version;
int show_help;
int singlethread;
char *mountpoint;
char *uid_file;
char *gid_file;
GHashTable *uid_map;
GHashTable *gid_map;
GHashTable *r_uid_map;
GHashTable *r_gid_map;
unsigned max_read;
unsigned max_write;
unsigned ssh_ver;
int sync_write;
int sync_read;
int sync_readdir;
int direct_io;
int debug;
int verbose;
int foreground;
int reconnect;
int delay_connect;
int passive;
char *host;
char *base_path;
GHashTable *reqtab;
GHashTable *conntab;
pthread_mutex_t lock;
unsigned int randseed;
int max_conns;
struct conn *conns;
int ptyfd;
int ptypassivefd;
int connvers;
int server_version;
unsigned remote_uid;
unsigned local_uid;
unsigned remote_gid;
unsigned local_gid;
int remote_uid_detected;
unsigned blksize;
char *progname;
long modifver;
unsigned outstanding_len;
unsigned max_outstanding_len;
pthread_cond_t outstanding_cond;
int password_stdin;
char *password;
int ext_posix_rename;
int ext_statvfs;
int ext_hardlink;
int ext_fsync;
struct fuse_operations *op;
uint64_t bytes_sent;
uint64_t bytes_received;
uint64_t num_sent;
uint64_t num_received;
unsigned int min_rtt;
unsigned int max_rtt;
uint64_t total_rtt;
unsigned int num_connect;
uint32_t flags;
uint64_t size = 0;
uint32_t uid = 0;
uint32_t gid = 0;
uint32_t atime = 0;
uint32_t mtime = 0;
uint32_t mode = S_IFREG | 0777;
stbuf->st_uid = uid;
stbuf->st_gid = gid;
stbuf->st_atime = atime;
stbuf->st_ctime = stbuf->st_mtime = mtime;
uint64_t bsize;
uint64_t frsize;
uint64_t blocks;
uint64_t bfree;
uint64_t bavail;
uint64_t files;
uint64_t ffree;
uint64_t favail;
uint64_t fsid;
uint64_t flag;
uint64_t namemax;
stbuf->f_bsize = bsize;
stbuf->f_frsize = frsize;
stbuf->f_blocks = blocks;
stbuf->f_bfree = bfree;
stbuf->f_bavail = bavail;
stbuf->f_files = files;
stbuf->f_ffree = ffree;
stbuf->f_favail = favail;
stbuf->f_namemax = namemax;
int res;
char buf[256];
const char *passwd_str = "assword:";
int timeout = 60 * 1000;
int passwd_len = strlen(passwd_str);
int len = 0;
char c;
struct pollfd fds[2];
fds[0].fd = conn->rfd;
fds[0].events = POLLIN;
fds[1].fd = sshfs.ptyfd;
fds[1].events = POLLIN;
res = poll(fds, 2, timeout);
size_t size = getpagesize();
memset(sshfs.password, 0, size);
munmap(sshfs.password, size);
sshfs.password = NULL;
int err;
int sock;
int opt;
struct addrinfo *ai;
struct addrinfo hint;
memset(&hint, 0, sizeof(hint));
hint.ai_family = PF_INET;
hint.ai_socktype = SOCK_STREAM;
err = getaddrinfo(host, port, &hint, &ai);
int res;
struct buffer buf;
struct iovec iovout[SFTP_MAX_IOV];
unsigned i;
unsigned nout = 0;
assert(count <= SFTP_MAX_IOV - 1);
buf_init(&buf, 9);
buf_add_uint32(&buf, iov_length(iov, count) + 5);
buf_add_uint8(&buf, type);
buf_add_uint32(&buf, id);
buf_to_iov(&buf, &iovout[nout++]);
for (i = 0; i < count; i++)
iovout[nout++] = iov[i];
pthread_mutex_lock(&conn->lock_write);
res = do_write(conn, iovout, nout);
pthread_mutex_unlock(&conn->lock_write);
buf_free(&buf);
return res;
int res;
struct buffer buf2;
uint32_t len;
buf_init(&buf2, 5);
res = do_read(conn, &buf2);
req->conn->req_count--;
buf_free(&req->reply);
sem_destroy(&req->ready);
g_free(req);
struct read_req *rreq;
rreq = list_entry(chunk->reqs.prev, struct read_req, list);
list_del(&rreq->list);
buf_free(&rreq->data);
g_free(rreq);
pthread_mutex_lock(&sshfs.lock);
chunk_put(chunk);
pthread_mutex_unlock(&sshfs.lock);
int res;
struct buffer buf;
uint8_t type;
struct request *req;
uint32_t id;
buf_init(&buf, 0);
res = sftp_read(conn, &type, &buf);
gettimeofday(&now, NULL);
difftime = (now.tv_sec - req->start.tv_sec) * 1000;
difftime += (now.tv_usec - req->start.tv_usec) / 1000;
sshfs.total_rtt += difftime;
sshfs.num_received++;
sshfs.bytes_received += msgsize;
req->reply = buf;
req->reply_type = type;
req->replied = 1;
pthread_mutex_lock(&sshfs.lock);
request_free(req);
pthread_mutex_unlock(&sshfs.lock);
pthread_mutex_lock(&sshfs.lock);
conn->processing_thread_started = 0;
close_conn(conn);
g_hash_table_foreach_remove(sshfs.reqtab, (GHRFunc) clean_req, conn);
conn->connver = ++sshfs.connvers;
sshfs.outstanding_len = 0;
pthread_cond_broadcast(&sshfs.outstanding_cond);
pthread_mutex_unlock(&sshfs.lock);
memmove(buf.p, buf.p + 1, buf.size - 1);
buf.len = 0;
buf2.p = buf.p + buf.size - 1;
buf2.size = 1;
res = do_read(conn, &buf2);
int res = -1;
uint32_t version = 0;
struct buffer buf;
buf_init(&buf, 0);
int flags;
uint32_t id = sftp_get_id();
uint32_t replid;
uint8_t type;
struct buffer buf;
struct stat stbuf;
struct iovec iov[1];
buf_init(&buf, 5);
buf_add_string(&buf, ".");
buf_to_iov(&buf, &iov[0]);
sshfs.remote_uid = stbuf.st_uid;
sshfs.local_uid = getuid();
sshfs.remote_gid = stbuf.st_gid;
sshfs.local_gid = getgid();
sshfs.remote_uid_detected = 1;
int flags;
uint32_t id = sftp_get_id();
uint32_t replid;
uint8_t type;
struct buffer buf;
struct stat stbuf;
struct iovec iov[1];
int err = -1;
buf_init(&buf, 0);
buf_add_string(&buf, remote_dir);
buf_to_iov(&buf, &iov[0]);
req->want_reply = want_reply;
req->end_func = end_func;
req->data = data;
sem_init(&req->ready, 0, 0);
buf_init(&req->reply, 0);
pthread_mutex_lock(&sshfs.lock);
begin_func(req);
id = sftp_get_id();
req->id = id;
req->conn = conn;
req->conn->req_count++;
err = start_processing_thread(conn);
const char *l = *linkp;
const char *b = sshfs.base_path;
char *newlink;
char *s;
int dotdots;
int i;
int err = 0;
int outstanding = 0;
int max = READDIR_START;
GList *list = NULL;
int want_reply;
pthread_mutex_lock(&sshfs.lock);
req->want_reply = 0;
want_reply = req->want_reply;
pthread_mutex_unlock(&sshfs.lock);
int err;
struct conn *conn;
struct buffer buf;
struct dir_handle *handle;
buf_finish(&handle->buf);
pthread_mutex_lock(&sshfs.lock);
handle->conn = conn;
handle->conn->dir_count++;
pthread_mutex_unlock(&sshfs.lock);
fi->fh = (unsigned long) handle;
int err;
struct dir_handle *handle;
handle = (struct dir_handle*) fi->fh;
err = sftp_request(handle->conn, SSH_FXP_CLOSE, &handle->buf, 0, NULL);
pthread_mutex_lock(&sshfs.lock);
handle->conn->dir_count--;
pthread_mutex_unlock(&sshfs.lock);
buf_free(&handle->buf);
g_free(handle);
return err;
int err;
struct buffer buf;
buf_init(&buf, 0);
buf_add_path(&buf, path);
buf_add_uint32(&buf, SSH_FILEXFER_ATTR_PERMISSIONS);
buf_add_uint32(&buf, mode);
buf_init(&buf, 0);
buf_add_string(&buf, from);
buf_add_path(&buf, to);
int err;
struct buffer buf;
buf_init(&buf, 0);
buf_add_path(&buf, path);
int err;
struct buffer buf;
buf_init(&buf, 0);
buf_add_path(&buf, from);
buf_add_path(&buf, to);
buf_init(&buf, 0);
buf_add_string(&buf, SFTP_EXT_POSIX_RENAME);
buf_add_path(&buf, from);
buf_add_path(&buf, to);
buf_init(&buf, 0);
buf_add_string(&buf, SFTP_EXT_HARDLINK);
buf_add_path(&buf, from);
buf_add_path(&buf, to);
struct buffer buf;
struct buffer outbuf;
struct stat stbuf;
struct sshfs_file *sf;
struct request *open_req;
struct conntab_entry *ce;
uint32_t pflags = 0;
struct iovec iov;
uint8_t type;
uint64_t wrctr = 0;
sf->connver = sf->conn->connver;
pthread_mutex_unlock(&sshfs.lock);
buf_init(&buf, 0);
buf_add_path(&buf, path);
buf_add_uint32(&buf, pflags);
buf_add_uint32(&buf, SSH_FILEXFER_ATTR_PERMISSIONS);
buf_add_uint32(&buf, mode);
buf_to_iov(&buf, &iov);
curr_list = sf->write_reqs.prev;
list_del(&sf->write_reqs);
list_init(&sf->write_reqs);
list_add(&write_reqs, curr_list);
struct buffer buf;
struct sshfs_file *sf = get_sshfs_file(fi);
buf_init(&buf, 0);
buf_add_string(&buf, SFTP_EXT_FSYNC);
buf_add_buf(&buf, &sf->handle);
err = sftp_request(sf->conn, SSH_FXP_EXTENDED, &buf, SSH_FXP_STATUS, NULL);
buf_free(&buf);
return err;
pthread_mutex_lock(&sshfs.lock);
sf->conn->file_count--;
ce = g_hash_table_lookup(sshfs.conntab, path);
ce->refcount--;
int err;
struct buffer buf;
struct iovec iov[1];
struct read_req *rreq;
size_t bsize = size < sshfs.max_read ? size : sshfs.max_read;
rreq = g_new0(struct read_req, 1);
rreq->sio = &chunk->sio;
rreq->size = bsize;
buf_init(&rreq->data, 0);
list_add(&rreq->list, &chunk->reqs);
buf_init(&buf, 0);
buf_add_buf(&buf, handle);
buf_add_uint64(&buf, offset);
buf_add_uint32(&buf, bsize);
buf_to_iov(&buf, &iov[0]);
buf += rreq->res;
size -= rreq->res;
list_del(&rreq->list);
buf_free(&rreq->data);
g_free(rreq);
chunk = sshfs_send_read(sf, size, offset);
pthread_mutex_lock(&sshfs.lock);
chunk->modifver = sshfs.modifver;
chunk_put(*chunkp);
*chunkp = chunk;
chunk->refs++;
pthread_mutex_unlock(&sshfs.lock);
int res = 0;
size_t total = 0;
struct read_chunk *chunk;
struct read_chunk *chunk_prev = NULL;
size_t origsize = size;
int curr_is_seq;
pthread_mutex_lock(&sshfs.lock);
curr_is_seq = sf->is_seq;
sf->is_seq = (sf->next_pos == offset && sf->modifver == sshfs.modifver);
sf->next_pos = offset + size;
sf->modifver = sshfs.modifver;
chunk = search_read_chunk(sf, offset);
pthread_mutex_unlock(&sshfs.lock);
chunk_prev = chunk;
size -= chunk->size;
offset += chunk->size;
chunk = NULL;
struct buffer buf;
struct iovec iov[2];
size_t bsize = size < sshfs.max_write ? size : sshfs.max_write;
buf_init(&buf, 0);
buf_add_buf(&buf, handle);
buf_add_uint64(&buf, offset);
buf_add_uint32(&buf, bsize);
buf_to_iov(&buf, &iov[0]);
iov[1].iov_base = (void *) wbuf;
iov[1].iov_len = bsize;
buf_free(&buf);
size -= bsize;
wbuf += bsize;
offset += bsize;
struct buffer buf;
struct iovec iov[2];
size_t bsize = size < sshfs.max_write ? size : sshfs.max_write;
buf_init(&buf, 0);
buf_add_buf(&buf, handle);
buf_add_uint64(&buf, offset);
buf_add_uint32(&buf, bsize);
buf_to_iov(&buf, &iov[0]);
iov[1].iov_base = (void *) wbuf;
iov[1].iov_len = bsize;
buf_free(&buf);
size -= bsize;
wbuf += bsize;
offset += bsize;
int err;
struct buffer buf;
struct buffer outbuf;
buf_init(&buf, 0);
buf_add_string(&buf, SFTP_EXT_STATVFS);
buf_add_path(&buf, path);
tmp = g_strdup_printf("-o%s", arg);
ssh_add_arg(tmp);
g_free(tmp);
tmp = g_strdup_printf("-oPort=%s", arg + 2);
ssh_add_arg(tmp);
g_free(tmp);
char argv0[] = "";
char argv1[] = "-o";
char *argv[] = { argv0, argv1, sshfs.workarounds, NULL };
struct fuse_args args = FUSE_ARGS_INIT(3, argv);
char *s = sshfs.workarounds;
memset(sshfs.password, 0, size);
munmap(sshfs.password, size);
sshfs.password = NULL;
int res;
struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
char *tmp;
char *fsname;
const char *sftp_server;
struct fuse *fuse;
struct fuse_session *se;
int i;
sshfs.renamexdev_workaround = 0;
sshfs.truncate_workaround = 0;
sshfs.buflimit_workaround = 0;
sshfs.createmode_workaround = 0;
sshfs.ssh_ver = 2;
sshfs.progname = argv[0];
sshfs.max_conns = 1;
sshfs.ptyfd = -1;
sshfs.dir_cache = 1;
sshfs.show_help = 0;
sshfs.show_version = 0;
sshfs.singlethread = 0;
sshfs.foreground = 0;
sshfs.ptypassivefd = -1;
sshfs.delay_connect = 0;
sshfs.passive = 0;
sshfs.detect_uid = 0;
sshfs.uid_map = NULL;
sshfs.gid_map = NULL;
sshfs.r_uid_map = NULL;
sshfs.r_gid_map = NULL;